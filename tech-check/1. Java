Basic

1.  JVM, JDK, JRE

    JVM (Java Virtual Machine) - компонент который переводит byte-код полученный от компилятора
        в машинный код понятный для операционной системы.

    JRE (Java Runtime Environment) - содержит в себе JVM и библиотеки классов Java, а также компоненты для запуска
        приложений написанных на Java.

    JDK (Java Development Kit) - платформозависимый комплект разработки программного обеспечения, который содержит JRE,
        компилятор, дебаггер, Javadoc и другие компоненты, необходимые для разработки,
        отладки и запуска программ или приложений Java.

2.  Для чего нужна JVM?

    JVM (Java Virtual Machine) - компонент который переводит byte-код полученный от компилятора
        в машинный код понятный для операционной системы.

3.  Что такое JIT?

    JIT (Just-In-Time) - компилятор, компонент JRE, который повышает производительность
        приложений Java во время их выполнения. Часто вызываемые методы (определяется специальным внутренним счетчиком)
        компилируются после запуска JVM, редко вызываемые непосредственно во время выполнения программы при их вызове.

4.  В чем достоинства и недостатки Java в сравнении с другими языками программирования?

    Достоинства:
        - OOP (Object-oriented programming) - модульность программы, многократное использование кода
            и остальные плюсы объектно-ориентированного программирования.
        - язык высокого уровня, приближенный к человеческому, простота понимания лексики, проще писать, дебажить...
        - кроссплатформенность - можно переносить и запускать программы на разных операционных системах,
            это удобно и очень важно для WEB приложений.
        - security - встроенные функции защиты.
        - распределенное использование
        - опыт и развитие...

    Недостатки:
        - плата за коммерческое использование (с 2019 года - дело Google/Android vs Oracle)
        - меньшая производительность - плата за высокоуровневость.
            JVM приходится компилировать программный код в машинный.
            Также есть еще дополнительные причины падения производительности -
        - многословность кода - плата за высокоуровневость.

Advanced
1. Что такое Classloader?

    Classloader механизм в Java, используется для загрузки в JVM скомпилированного byte-кода.
    Базовый загрузчик (bootstrap) это механизм низкого уровня, его реализация включена в JVM.
    Остальные загрузчики являются наследниками абстрактного класса Classloader.
    Загрузку классов обеспечивают наследники.
    System or Application загружает классы уровня приложения.
    Extension загружает классы расширения из библиотеки JDK.
    Bootstrap загружает внутренние стандартные классы JDK.

2. Что такое динамическая загрузка классов?

    Java поддерживает ленивую динамическую загрузку классов -
        Classloader вызывается только тогда когда JVM дает запрос на загрузку класса.

        JVM проверяет загружен ли класс,
            если да - продолжает выполнение программы,
            если нет, то дает запрос на загрузку класса в подсистему Classloader.
                Подсистема Classloader дает запрос загрузчику System/Application Classloader.
                System Classloader ищет доступен ли ему этот класс
                    если да, то этот класс возвращается,
                    если нет, то запрос передается загрузчику расширений Extension Classloader
                    Extension Classloader ищет доступен ли ему этот класс
                        если да, то этот класс возвращается,
                        если нет, то запрос передается загрузчику внутренних классов Bootstrap Classloader
                        Bootstrap Classloader ищет доступен ли ему этот класс
                            если да, то этот класс возвращается,
                            если нет, то выдается исключение Exception.

3. Модель памяти в Java

    Java модель памяти, используемая в JVM, делит память на стеки потоков (thread stack) и кучу (heap).
    Каждый поток имеет свой stack.
    Heap хранит все объекты приложения, независимо от того какой поток создал объект и классы JRE.
    Stack хранит все переменные примитивного типа и ссылки на объекты данного потока хранящегося в Heap.

4. Что такое heap и stack? Как организованы? Какая между ними разница?

    Heap хранит все объекты приложения, независимо от того какой поток создал объект и классы JRE.
    Heap используется всеми частями приложения.
    Garbage Collector работает с Heap.

    Память Stack используется для выполнения потока.
    Stack хранит для данного метода все локальные переменные примитивного типа
    и ссылки на другие объекты хранящиеся в Heap.

    Stack быстрее.
    Heap больше по объему.

5. Что такое Permanent Generation и Metaspace?

    PermGen (Permanent Generation) специальное место в Heap, отделенное от основной памяти,
    в которой хранились метаданные загруженных классов, статическое содержимое приложения, переменные примитивных
    типов и ссылки на статические объекты, данные о byte-коде и JIT информацию. Ограничивалось максимальный размер
    этой области памяти или дефолтным значением или установленными значениями. Удалена с JDK 8.
    Из-за ограниченного объема являлось причиной возникновения ошибка OutOfMemoryError, загрузчики памяти не управлялись
    Garbage Collector правильно и являлись причиной утечки памяти.

    Metaspace - новая область памяти заменившая PermGen с JDK 8. Metaspace может увеличиваться автоматически,
    также есть возможность управлять памятью. Garbage Collector теперь автоматически удаляет из памяти ненужные классы,
    когда емкость для хранения метаданных заполняется. Вероятность возникновения ошибки OutOfMemoryError уменьшилась

6. Принцип работы Garbage Collector.

    Garbage Collector неиспользуемые объекты, на которые отсутствуют ссылки с других объектов.

    GC работает в два шага:
    mark - здесь GC определяет, какие участки памяти используются, а какие нет.
    sweep - на этом этапе удаляются объекты, помеченные как неиспользуемые на первом этапе.

    Преимущества:
    - нет ручного выделение / освобождения памяти
    - автоматические управление утечками памяти

    Недостатки:
    - такой принцип требует большего задействования процессора, чем нужно для простого выполнения программы
    - нет контроля над планированием процессорного времени,
        необходимого для освобождения памяти от неиспользуемых объектов.
    - не так эффективно как ручное выделение/освобождение памяти.

    с Java 8 проверяются и удаляются объекты с циклическими ссылками друг на друга.