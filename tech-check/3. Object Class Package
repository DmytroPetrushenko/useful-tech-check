Basic
1. Что такое ООП?

    Объектно-ориентированное программирование – это подход, при котором вся программа рассматривается
    как набор взаимодействующих друг с другом объектов. У каждого объекта в системе есть свойства и поведение,
    как и у любого реального объекта. Эти свойства и поведения, как шаблоны описываются в классах.
    Классы дают возможность создания объектов объединенных по свойствам
    и поведению в определенные блоки.

2. Основные принципы ООП? Инкапсуляция, наследование, полиморфизм, абстракция. Примеры.

    Абстракция - abstraction - способ представления какого-либо элемента из реального мира в виде объекта в программе,
        учитывая только важные для данной программы свойства и поведения элемента. Это такое себе обобщение информации
        о свойствах или поведении объектов. При этом особо не вникая в суть что и как работает внутри
        Пример. Транспорт - это обобщение - абстракция - есть одно общее свойство - перемещение чего либо в
        пространстве. Но транспорт - это и автомобиль, и велосипед, и катер, и самолет. То есть обычно у абстракции
        есть определенное ветвление/уточнение вниз. Определяют даже уровни абстракции. Пример. Автомобиль - они бывают
        грузовые, легковые, спортивные - это будет уже следующим уровнем абстракции относительно Транспорта. При этом
        легковые могут быть купе, универсал, седан, хетчбэк и т.д. В Java для этого могут использоваться abstract class
        и interface.

    Наследование - inheritance - тесно связано с абстракцией, Автомобиль имеет свойства транспорта - наследует их,
        грузовой автомобиль имеет свойства Автомобиля и наследует свойства транспорта и свойства автомобиля и т.д.
        Наследование позволяет передавать свойства от родителя к наследнику.

    Полиморфизм - polymorphism - это свойство которое позволяет объектам иметь общие свойства от родителя, но тем
        не менее быть разными и иметь свои особенности. Пример. Грузовой автомобиль имеет способность перемещать
        определенный вес и объем груза, при этом легковой автомобиль может перемещать определенное количество
        пассажиров, иметь определенные уровни комфорта, которых нет в грузовом автомобиле. При этом грузовой автомобиль
        также может перевозить какое-то количество людей, а легковой какое-то количество груза. В Java для этого
        используются overloading и overriding.

    Инкапсуляция - encapsulation - это свойство позволяет нам скрыть на определенном уровне способы реализации свойств
        или поведения объектов. Пример. Обычному водителю не обязательно знать как работает ДВС или сцепление, или
        электродвигатель в автомобиле, какие технологии и как они использованы в автомобиле - от него эта информация
        скрыта. Или например производитель автомобилей не хочет чтобы водитель или конкуренты меняли свойства его
        автомобиля. Поэтому данные скрываются (инкапсулируются) и доступны только специальным сервисным центрам.
        В Java для этого используются модификаторы доступа private, protected, package-protected, public.

3. Можно ли при override метода изменить: модификатор, return type, тип аргументов и их количество,
    название аргументов, exception?

    - у override метода должен быть такой же модификатор доступа как у родителя, либо шире
    - у override метода должен быть тот же возвращаемый тип
    - у override метода должны быть такие же по типу аргументы и их количество, как у метода родителя
    - сами названия аргументов могут отличаться
    - у override метода exception может отличаться, но должен быть не шире чем у класса родителя

4. Что будет если передать массив в метод, который изменит его значения? Изменится ли оно за пределами метода? Почему?

    При передаче параметров в Java используется метод "pass by value", то есть передается копия.
    Если передать массив в метод, то мы передаем копию ссылки на массив, а значит по этой ссылке можем поменять массив.

5. Как сохраняются объекты в памяти? Передача параметров "по ссылке", как это работает?

    В stack хранятся значения примитивов и ссылки на объекты. Сами объекты хранятся в heap.
    При передаче параметров в Java используется метод "pass by value", то есть для примитивов передается копия
    значения, для объектов также передается копия значения ссылки - копия ссылки на тот же объект лежащий в heap.

6. Что такое пакет? Как создать пакет?

    Пакет в Java используется для группировки связанных по какому-то принципу классов. Как папка в каталоге файлов.
    Используются пакеты для избегания конфликта имен и удобства поддержания и разработки кода. В Java есть встроенные
    пакеты их можно импортировать import. Также можно подключать расширения с пакетами и также их импортировать.
    В пакетах хранятся классы - их можно импортировать отдельно.
    import package.name.Class - импорт класса
    import package.name.* - импорт пакета
    Можно создавать свои пакеты с помощью слова package. Java использует каталог файловой системы для хранения пакетов.

    package mypackage;
    class MyClass {...}

    javac MyClass.java - компилируем класс
    javac -d . MyClass.java - java создает пакет в указанном месте (если в том же каталоге то ".", вместо этого
    можно написать путь).

7. Рассказать про все модификаторы доступа.

    Модификаторы доступа в Java определяют доступность или область видимости поля, метода, конструктора, класса.
    Мы можем устанавливать уровень доступности при помощи модификаторов доступа:

    public - общедоступный уровень - доступ можно получить из любого места программы - из любого класса и пакета.

    protected - защищенный уровень - доступ можно получить внутри текущего пакета или через класс наследник вне пакета.
        Нельзя использовать для класса.

    package-protected - уровень по умолчанию - доступ можно получить только внутри текущего пакета.

    private - приватный уровень - доступ можно получить только в пределах класса. Не доступен за пределами класса.
        Если использовать для конструктора - то экземпляр класса можно создать только в пределах этого класса.

8. Разместить модификаторы доступа по степени открытости.

    - public - самый открытый
    - protected
    - package-protected / default
    - private - самый закрытый

9. Какие модификаторы доступа могут быть у класса?

    - public
    - package-protected / default
    - private

10. Что такое класс? Объект?

    Класс и объект - это базовые понятия ООП.
    Класс - это план или прототип, на основе которого создаются объекты. Он содержит набор свойств или методов,
    которые являются общими для всех объектов одного типа/класса.

    {модификатор доступа}
    {class}
    {Название класса}
    {???extends}
    {Название супер класса}
    {???implements}
    {Название интерфейса, Название второго интерфейса...}
    {тело класса}

    Объект - это базовая единица ООП и представляет собой сущности из реальной жизни. В программе Java создаются
    объекты, которые взаимодействуют между собой при помощи методов. Создаются по плану / прототипу описанному в классе.
    Аргументы определяют его состояние.
    Методы определяют его поведение.
    Имя дает идентификацию для взаимодействия с другими объектами.

11. Зачем нужен instanceOf?

    instanceOf проверяет, является ли ссылка на объект в левой части выражения,
    экземпляром класса в правой части выражения

12. Что может быть final?

    Класс, метод, переменные, в том числе аргументы методов.
    Класс final не может иметь наследников.
    Метод final не может быть переопределен Override.
    Переменные примитивного типа final не могут быть изменены после присвоения значения.
    Для ссылочных типов final не может быть изменена ссылка на объект.
    Ссылку изменить нельзя - состояние объекта можно.

13. Может ли метод интерфейса быть final?

    нет

14. Что такое static? Что может быть static?

    В Java словом static помечают поля или методы, которые принадлежат классу, а не объекту класса,
    то есть поля и методы которые для всех объектов класса будут общими.

    static могут быть:
    - константы,
    - переменные,
    - методы,
    - блоки инициализации,
    - импорты
    - вложенные классы (nested classes).

    Статические поля используются:
    - если значение поля должно быть общим для всех объектов этого класса,
    - значение поля не зависит он наличия объектов класса,
    - значение поля может быть изменено из любого объекта этого класса, и изменится для всех объектов этого класса

    Статические методы используются:
    - для доступа к статическим переменным и другими статическими методами, которые не зависят от объектов
    - для служебных, вспомогательных классов и интерфейсов, поскольку не требуют создания объектов
    - когда методы требуется доступ только к статическим полям класса

    Статические блоки инициализации используются:
    - для инициализации статических переменных, когда это неудобно или невозможно сделать непосредственно во время
        объявления переменной.
    - либо статические переменные для инициализации требуют многострочного кода.

    Статический импорт используется:
    - улучшения читаемости кода, при использовании статических методов и переменных без указания имени класса.

15. Можно ли перегрузить/переопределить статические методы?

    Перегружать можно.
    Переопределять нельзя.

16. В чем разница между переменной экземпляра класса и статической переменной?

    Статическая переменная:
    - общая для всех объектов данного класса,
    - если один объект изменил статическую переменную, то она поменялась для всех экземпляров объекта этого класса,
    - создаются при запуске программы и удаляются после ее завершения.
    - доступ из другого класса по ClassName.VariableName

    Переменная экземпляра класса:
    - для каждого объекта свой экземпляр переменной,
    - изменяется только для данного экземпляра класса,
    - создается когда создается объект при помощи new и удаляется вместе с объектом,
    - для доступа из другого класса нужен объект экземпляр класса.

17. Может ли класс быть статическим?

    Можно создать статический вложенный класс. Он может быть создан без создания экземпляра внешнего класса.
    Статический вложенный класс имеет доступ только к статическим переменным.

18. Отличия внутреннего класса от вложенного.

    Внутренний класс имеет связь с объектом внешнего класса.
    Вложенный статический класс имеет доступ только к статическим переменным и не связан с объектам внешнего класса.

19. Можно ли использовать статические методы внутри обычных? Наоборот? Почему?

    Статические методы можно использовать внутри обычных, так как они принадлежат всем экземплярам класса.
    Нестатические методы нельзя использовать внутри статических.
    Можно получить доступ к нестатическим полям или методам только после создания объекта класса внутри
    статического метода и вызвать нестатический метод или переменную на этом объекте.

20. Что такое конструктор? Конструктор по умолчанию?

    Конструктор это блок кода похожий на метод, который вызывается при создании объекта класса. После создания через
    конструктор выделяется место в памяти. Имя конструктора совпадает с именем класса. Конструктор не должен иметь
    явного возвращаемого типа. Конструктор также инициализирует состояние объекта. Конструктор может быть перегружен.
    Если в классе отсутствует конструктор, то вызывается конструктор по умолчанию, без параметров.
    Если в классе есть конструктор с параметрами, а нужен также конструктор без параметров, то его надо создать явно.

21. Что такое this и super?

    this зарезервированное слово, используется для ссылки на экземпляр текущего класса. Можно ссылаться на переменную
    экземпляра текущего класса, передавать как аргумент в метод или конструктор, для возврата экземпляра текущего класса.

    super зарезервированное слово, используется для ссылки на єкземпляр суперкласса, для вызова метода или конструктора
    супер класса. Может ссылаться на переменную суперкласса, на метод суперкласса или конструктор суперкласса.

22. Как вызвать один конструктор в другом?

    использовать this() для конструкторов в том же классе,
    использовать super() для вызова конструктора родительского класса.

    слова this() или super() должны быть на первой строке конструктора.
    должен быть по крайней мере один конструктор без this().

    Использование цепочек конструкторов позволяет избежать повторяемости кода.

23. Как вызвать конструктор родительского класса?

    использовать super() для вызова конструктора родительского класса.
    слово super() должно быть на первой строке конструктора.

24. Какой порядок вызова конструкторов, переменных, и блоков инициализации с учетом иерархии классов?

    - первыми выполняются статические блоки и инициализируются переменные родительского класса в том порядке,
    в котором расположены именно статические блоки и переменные в коде,
    - затем выполняются статические блоки и переменные класса наследника в том порядке,
    в котором расположены именно статические блоки и переменные в коде,
    - затем выполняются блоки инициализации родительского класса, в том порядке в котором они расположены в коде,
    - затем выполняются блоки инициализации создаваемого класса, в том порядке в котором они расположены в коде,
    - затем выполняется конструктор

25. Клас Object, количество методов, все методы кроме wait, notify, notifyAll, назвать и пояснить, как работают.

    Object это родительский класс всех классов, находящийся на вершине иерархии классов, каждый класс
    наследник Object прямой или непрямой. Каждый класс наследует методы класса Object и если нужно их использовать -
    то надо их переопределить, учитывая специфику класса для которого используются эти методы.

    - clone() - создает копию объекта на котором вызывается. При условии что класс или один из его супер классов
        реализовывает интерфейс Cloneable. Возвращает созданный объект такого же класса и инициализирует переменные
        нового объекта, чтобы они имели такие же значения как клонируемый объект. Если клонируемый объект содержит
        переменную ссылку на внешний объект, то надо переопределять метод clone().
    - equals() - показывает "равен" / "эквивалентен" ли объект другому объекту. По умолчанию используется "==",
        что для примитивных типов работает хорошо. Для ссылочных по умолчанию сравниваются ссылки.
    - finalize() - вызывается Garbage Collector для объекта, когда определено что на объект больше нет ссылок.
    - getClass() - возвращает объект Class, который можно использовать для получения имени класса, имени суперкласса,
        интерфейсы которые он реализует, поля и т.д. Используется в Reflection.
    - hashCode() - возвращает хеш-код объекта, целочисленное значение в диапазоне int,
        сгенерированное алгоритмом хеширования. По определению если объекты равны по equals() их hashCode()
        тоже должны быть равны. Но равенство hashCode() не гарантирует эквивалентность.
    - toString() - возвращает строчное представление объекта. Для строчных и примитивных переменных работает правильно.
        Для объектов необходимо переопределять - так как возвращает строчное представление "ссылки" на объект.

26. Equals и hashcode.

    - equals() - показывает "равен" / "эквивалентен" ли объект другому объекту. По умолчанию используется "==",
        что для примитивных типов работает хорошо. Для ссылочных по умолчанию сравниваются ссылки.
        Необходимо переопределять и по возможности сравнивать ссылки, затем того же ли класса объект, и еквивалентны ли
        его поля.

    - hashCode() - возвращает хеш-код объекта, целочисленное значение в диапазоне int,
        сгенерированное алгоритмом хеширования. По определению если объекты равны по equals() их hashCode()
        тоже должны быть равны. Но равенство hashCode() не гарантирует эквивалентность.
        При переопределении часто используются простые числа, а также хеш коды полей. По возможности нужно стремиться
        к уникальности, а если не получается то к максимальной распределенности в диапазоне чисел.

27. Правила переопределения equals().

    рефлексивность : объект должен быть эквивалентен сам себе,
    симметричность : x.equals(y) должен возвращать тот же результат, что и y.equals(x),
    транзитивность : если x.equals(y) и y.equals(z), то также x.equals(z)
    последовательность : значение equals() должно изменяться, только если меняется свойство,
        которое содержится в equals() (случайности недопустимы).

28. Правила переопределения hashCode().

    внутренняя согласованность : значение hashCode() может измениться,
        только если меняется свойство используемое в equals(),
    консистентность :  объекты, которые еквивалентны друг другу, должны иметь одинаковый хеш-код
    коллизия : равенство hashCode() не гарантирует эквивалентность.

29. Что такое абстрактный метод?

    Абстрактный метод это метод без реализации.

30. Что такое абстрактный класс? Чем отличается от обычного?

    Если класс содержит хотя бы один абстрактный метод, то он тоже объявляется абстрактным.
    При этом абстрактный класс может не иметь абстрактных методов.
    Экземпляр абстрактного класса нельзя создать. Могут иметь как абстрактные, без реализации, так и обычные,
    с реализацией, методы. Если наследник расширяет абстрактный класс, то он должен либо реализовать все абстрактные
    методы, либо, если не реализует, должен быть объявлен абстрактным.

31. Может ли быть абстрактный класс без абстрактных методов?

    Да, может.

32. Может ли быть конструктор у абстрактного класса?

    Да, может. Но создать экземпляр такого класса не получится.

33. Что такое интерфейс? Чем отличается от абстрактного класса? 5+ отличий.

    - интерфейс описывает поведение, абстрактный клас может описывать как поведение так и состояние.
    - абстрактный класс связывает между собой родственные классы, интерфейс могут реализовывать классы, у которых нет
        вообще ничего общего.
    - переменные объявленные в интерфейсе по умолчанию static final,
        абстрактный класс может иметь final и не final, static и не static переменные.
    - абстрактный класс может реализовать интерфейс, интерфейс не может реализовать абстрактный класс.
    - класс реализовывает интерфейс через implements, и может реализовывать несколько интерфейсов,
        класс расширяет абстрактный класс через extends, и может расширять только один класс.
    - переменные в интерфейсе по умолчанию public, абстрактный класс может иметь и private, и protected переменные.
    - по умолчанию в интерфейсе все методы абстрактные, с Java 8 появились default методы с реализацией, которые можно
     переопределить в классе реализующем данный интерфейс, static методы с реализацией, не переопределяются.
        абстрактный класс может иметь как абстрактные, так и не абстрактные методы.

34. Что такое интерфейс маркер? Приведите пример.

    Это пустой интерфейс, без полей и методов, который просто показывает способность класса к определенным действиям.
    Cloneable - показывает, что объект может быть скопирован при помощи метода clone(). Класс его реализующий должен
    переопределить этот метод.

35. От чего можно создавать экземпляры: интерфейс или абстрактный класс?

    Ни от интерфейса, ни от абстрактного класса нельзя создать экземпляры.

36. В каком случае нужно использовать интерфейс, а в каком абстрактный класс?

    Интерфейс лучше использовать, когда разные реализации совместно используют только сигнатуру метода.
    Интерфейс описывает действие без привязки к объекту или его типу.
    Например: способность летать - для самолета и для птицы. Самолет и птица реализовывают этот процесс по разному.
    Абстрактный класс следует использовать, когда разные реализации одного типа имеют общее поведение.
    Абстрактный класс дает чертеж для наследников родственного типа.
    Например: у любой геометрической фигуры есть площадь, для каждой фигуры площадь вычисляется по разному.

37. Поля и методы в интерфейсе.

    Поля по определению все public static final.
    Методы стандартные по умолчанию public abstract - без тела - должны быть реализованы в классе его имплементирующем.
    Могут иметь public default - с телом - могут быть переопределены в классе его имплементирующем.
    Могут иметь static с разным типом доступа - не могут быть переопределены в классе его имплементирующем.

38. Default методы?

    По умолчанию имею тип доступа public и имеют реализацию. default методы были введены для решения проблемы
    расширения. Если интерфейс имплементируют много классов, то при введении обычного метода в интерфейс, в каждом из
    этих классов нужно будет переопределить этот метод, если этого не сделать - функциональность сломается.
    Если же ввести default методы, который имеет реализацию - они автоматически будут доступны в реализациях.
    Они дают возможность добавления дополнительной функциональности без возникновения ошибок в классах реализациях.
    Нужно быть осторожным с реализацией нескольких интерфейсов и одинаковыми сигнатурами методов:
    - либо явно переопределять такие методы в классах,
    - либо принудительно назначать из какого интерфейса брать реализацию через super.

39. Можно ли имплементировать класс от нескольких интерфейсов?

    Да, можно.

40. Что нужно чтобы у класса не было наследников?

    Сделать класс final.

41. Можно ли наследовать один интерфейс от другого? Сколько?

    Да можно. Интерфейс может наследовать несколько других интерфейсов.

42. Может ли интерфейс наследоваться от классов?

    Нет. Интерфейс может наследоваться только от интерфейсов.

43. Может ли в интерфейсе быть реализация вложенного класса?

   ??????????????????????????????????????

44. Что такое Enum? Для чего нужен? Какие имеет методы?

    Enum - это класс для создания ограниченного круга констант. Например - дни недели, или месяцы года.
    Enum полноценный класс. Но от него нельзя наследоваться. Перечисления enum пишутся по правилам именования констант.
    Каждому значению перечисления можно сопоставить дополнительное поле (значение) и для него создать переменную необходимого типа,
    конструктор, геттеры, переопределить toString() и добавить другие методы если это необходимо.
    Также для перечислений enum есть характерные для них методы:
    - values() - возвращает массив всех перечислений,
    - ordinal() - возвращает порядковый номер перечисления,
    - valueOf() - возвращает перечисление по переданному имени.

Advanced

1. Что такое High Cohesion и Low Coupling?

    High Cohesion - высокая сплоченность - принцип, который задает свойство сильной связи внутри
    определенного модуля, объединенного например одной бизнес-логикой.

    Low Coupling - слабая связь - модули программы должны быть максимально независимы от других модулей,
    чтобы изменения одного модуля минимально влияли на другие модули. По возможности один модуль не должен знать,
    как работает другой модуль. Тогда поддерживается большая стабильность работы, легкость внесения изменений,
    масштабируемость, модульное тестирование.

2. Контрвариантность, ковариантность, инвариантность.

    ????????????????????????????????????????????????????????

3. Как реализован метод equals()?

    По умолчанию это метод класса Object. Там он реализован как "==".
    Для примитивов он работает правильно.
    Для ссылочных объектов он сравнивает не сами объекты по полям, а сравнивает ссылки, поэтому для правильного
    сравнения по полям этот метод надо переопределять.
    Правила:
    рефлексивность : объект должен быть эквивалентен сам себе,
    симметричность : x.equals(y) должен возвращать тот же результат, что и y.equals(x),
    транзитивность : если x.equals(y) и y.equals(z), то также x.equals(z)
    последовательность : значение equals() должно изменяться, только если меняется свойство,
        которое содержится в equals() (случайности недопустимы).

4. Как реализован hashСode()?

    написан на другом языке помечен как native. целочисленное значение в диапазоне int,
    сгенерированное алгоритмом хеширования. По определению если объекты равны по equals() их hashCode()
    тоже должны быть равны. Но равенство hashCode() не гарантирует эквивалентность. Могут быть коллизии.
    При переопределении часто используются простые числа, а также хеш коды полей. По возможности нужно стремиться
    к уникальности, а если не получается то к максимальной распределенности в диапазоне чисел.
    Правила:
    внутренняя согласованность : значение hashCode() может измениться,
        только если меняется свойство используемое в equals(),
    консистентность :  объекты, которые еквивалентны друг другу, должны иметь одинаковый хеш-код
    коллизия : равенство hashCode() не гарантирует эквивалентность.


5. SOLID.

    Single Responsibility Principle (Принцип единственной ответственности).
        Принцип: Никогда не должно быть больше одной причины изменить класс или метод.
        Один класс или метод выполняет одну функцию.
        Пример: Если класс отвечает за работу с базой данных - то в нем нет бизнес логики.
        Если класс отвечает за обработку информации, то в нем нет работы с файлами и т.д.
    Open Closed Principle (Принцип открытости/закрытости).
        Принцип: программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения,
        но закрыты для изменения

    Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
        Принцип: объекты в программе можно заменить их наследниками без изменения свойств программы.

    Interface Segregation Principle (Принцип разделения интерфейса).
        Принцип: клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать. Лучше
        иметь несколько узконаправленных интерфейсов, чем один общий интерфейс.

    Dependency Inversion Principle (Принцип инверсии зависимостей).
        Принцип: Модули верхних уровней не должны зависеть от модулей нижних уровней.
        Абстракция не должна зависеть от имплементаций. Зависимости внутри системы строятся на основе абстракций.

























