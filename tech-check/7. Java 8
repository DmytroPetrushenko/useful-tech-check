Basic

1. Нововведения реализованные в Java 8.

    - Lambda
    - Functional Interface
    - default & static methods in interfaces
    - Optional
    - Method reference
    - Stream API
    - DateTime API
    - ...

2. Анонимные классы в Java

    Анонимный класс - это внутренний класс без имени. Поэтому он объявляется один раз в месте использования и
    не доступен для внешнего использования. Можно расширять существующий класс или реализовать интерфейс.
    Может существовать только один экземпляр этого класса.

3. Функциональные интерфейсы и где они используются

    Функциональный интерфейс - это интерфейс, у которого есть только один абстрактный метод. Самое популярное
    использование это в лямбда выражениях и метод референсах.
    Включает 4 основных типа:
    - Consumer - принимает один аргумент,производит с ним какие-то действия и ничего не возвращает.
    - Predicate - принимает аргумент, проводит проверку на условие и возвращает boolean.
    - Function - принимает один аргумент и возвращает значение после обработки.
    - Supplier - не принимает аргументов, возвращает одно значение.

4. Сколько абстрактных методов может содержать функциональный интерфейс?

    Функциональный интерфейс может содержать только один абстрактный метод.
    И неограниченно может содержать defaul и static методы.

5. Может ли функциональный интерфейс содержать defaul и static методы?

    Функциональный интерфейс может содержать только один абстрактный метод.
    И неограниченно может содержать defaul и static методы.

6. Обязательно ли использовать аннотацию @FunctionInterface над функциональным интерфейсом?
    Что будет если ее не поставить?

    Если интерфейс содержит только один абстрактный метод - он автоматически является функциональным.
    Следовательно аннотация не обязательна и носит скорее информационную составляющую.
    Однако если аннотация есть - а в интерфейсе будет более одного абстрактного метода - то аннотация будет
    подчеркиваться компилятором, как несоответствующая условиям.

7. Основные виды функциональных интерфейсов.

    - Consumer - принимает один аргумент,производит с ним какие-то действия и ничего не возвращает.
    - Predicate - принимает аргумент, проводит проверку на условие и возвращает boolean.
    - Function - принимает один (BiFunction - два) аргумент и возвращает значение после обработки.
    - Supplier - не принимает аргументов, возвращает одно значение.

8. Что представляет собой лямбда выражение?

    В основном лямбда выражения выражают экземпляры функциональных интерфейсов. Лямбда выражения реализовывают
    один абстрактный метод функционального интерфейса.
    Может иметь ноль, один или несколько операторов в круглых скобках.
    Если оператор один, то скобки можно не ставить.
    Если в лямбда выражении используется многострочное (несколько выражений) - то они берутся в фигурные скобки.

9. Привести аналог лямбды с использованием анонимного класса и простого класса.

    лямбда
    ----------------------------------------------
    Comparator<User> userComparator = (user1, user2) -> user1.getAge() - user2.getAge();
    ----------------------------------------------

    анонимный класс
    ----------------------------------------------
    Comparator<User> userComparator = new Comparator<>() {
        @Override
        public int compare(User user1, User user2) {
            return user1.getAge() - user2.getAge();
        }
    }
    ----------------------------------------------

    простой класс
    ----------------------------------------------
    package test.test.test;

    import java.util.Comparator;

    public class UserComparator implements Comparator<User> {
        @Override
        public int compare(User user1, User user2) {
            return 0;
        }
    }
    ----------------------------------------------

10. Что такое "ссылка на метод"?

    Ссылка на метод - method reference - это ссылка метод функционального интерфейса.
    Это компактная и простая форма лямбда выражения. Когда мы используем лямбда выражение только как ссылку на метод,
    тогда мы можем заменить лямбда выражение на ссылку на метод.

11. Что такое default метод в интерфейсе?

    default метод в интерфейсе - это метод в интерфейсе, который имеет реализацию по умолчанию, однако при реализации
    этого интерфейса мы можем переопределять его по своему.
    добавлены в Java 8 - для возможности добавлять методы в интерфейсы без опасности влияния на уже существующие
    классы реализующие этот интерфейс. Обратная совместимость поддерживается этими методами по умолчанию - добавление
    новых функций без разрушения старого кода.

12. Что такое static метод в интерфейсе?

    static метод в интерфейсе - это метод в интерфейсе, который имеет реализацию, но при реализации интерфейса мы не
    можем его переопределить.
    добавлены в Java 8 - для возможности добавлять методы в интерфейсы без опасности влияния на уже существующие
    классы реализующие этот интерфейс. Обратная совместимость поддерживается этими методами по умолчанию - добавление
    новых функций без разрушения старого кода. Подразумевают одинаковую функциональность метода интерфейса для всех
    случаев его использования.

13. Как вызвать default/static методы?

    default метод вызывается на экземпляре класса реализующего интерфейс содержащий этот default метод.
    static метод вызывается путем использования Имени интерфейса и имени static метода.

14. Может ли быть private метод с реализацией в интерфейсе? Без реализации?

   В интерфейсе могуть быть private методы. Улучшают возможности использования повторяющегося кода в интерфейсе.
   Приватный метод не может быть абстрактным - то есть обязательно должен быть с реализацией.

15. Какую проблемы решает Optional?

    Решает проблему с NullPointerException.
    Избавляет от необходимости писать повторяющийся код для проверки на null - эта проверка может реализовываться
    встроенными методами Optional.

16. Какими способами можно создать Optional?

    Optional.empty() - создает объект Optional с null внутри.
    Optional.of(User) - создает объект Optional c объектом User внутри, если передать null => NullPointerException.
    Optional.ofNullable(User) - создает объект Optional у которого может быть и null и User внутри.

17. Какими способами можно извлечь значение из Optional?

    get() - возвращает значение, если Optional пустой => NoSuchElementException.
    orElse() - возвращает значение, если Optional пустой => возвращает значение по умолчанию переданное как параметр.
    orElseGet() - возвращает значение, если Optional пустой => возвращает значение полученное от
        Supplier переданного как параметр.
    orElseThrow() - возвращает значение, если Optional пустой => возвращает переданное как параметр исключение.

18. В чем разница между orElse() orElseGet()?

    orElse() - возвращает значение, если Optional пустой => возвращает значение по умолчанию переданное как параметр.
    orElseGet() - возвращает значение, если Optional пустой => возвращает значение полученное от
        Supplier переданного как параметр.

19. Какими способами можно проверить, есть ли что-то в Optional?

    isEmpty() - возвращает true есть Optional пуст.
    isPresent() - возвращает true если Optional не пуст.

20. Что будет если вызовем Optional.get(), а внутри ничего не будет?

    get() - возвращает значение, если Optional пустой => NoSuchElementException.

21. Что такое Stream в Java?

    Stream - это последовательность объектов, которая поддерживает разные методы, которые могут быть конвейерными для
    получения желаемого результата.
    Stream не является структурой данных, он получает данные из коллекций, массивов или каналов ввода/вывода.
    Stream не изменяют входящую структуру данных - а выдает новый результат на основании их обработки.
    Источник данных => промежуточная операция + ... + промежуточная операция => терминальна операция

22. Какие есть способы создания Stream?

    - вызвать метод stream() на экземпляре коллекции - Stream<User> = listUsers.stream()
    - из перечисления значений или массива - Stream.of(user1, user2, ..., userN) или Stream.of(User[])
    - из массива - Arrays.stream(User[])
    - пустой Stream - Stream.empty()
    - Stream.Builder<User> userStreamBuilder = Stream.builder();
        Stream<User> userStream = userStreamBuilder.add(user1).add(user2)...add(userN)
    - Stream.iterate(value, Function()) создает неограниченный поток результатов обработки переданного значения,
        по переданной Function.
    - Stream.generate(Supplier()) создает неограниченный потом генерируемый переданным Supplier.

    Неограниченные Stream могут быть ограничены методом limit(quantity)

23. На какие два типа делятся операции над Stream?

    Промежуточные(intermediate) конвейерные - может быть какое угодно количество, возвращают новый Stream.
    Терминальные(terminal) - может быть только одна, возвращают результат или вызывают сторонний эффект.

24. Привести примеры промежуточных и терминальных операторов.

    Промежуточные - map(), flatMap(), filter(), sorted()
    Терминальные - findFirst(), count(), forEach()

25. В какой момент Stream начнет свое исполнение?

    После вызова терминального оператора.

26. Какая разница между map() и flatMap()?

    map() - преобразовывает стрим одних объектов в стрим других объектов.
    flatMap() - преобразовывает стрим объектов содержащих набор(массив, коллекцию, стрим) объектов в общий стрим
    этих объектов.







