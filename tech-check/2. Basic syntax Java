Basic

1. Какой оператор прерывает текущую итерацию цикла?

    continue

2. Какой оператор полностью прерывает цикл?

    break

3. Можно ли использовать return в методе, который возвращает void?

    можно, для прерывания выполнения метода

4. Таблица истинности

    ???????????????????????????????????

5. Разница между | и ||, & и &&

    | и & - побитовые, вычисляет обе стороны операции

    || и && - логические, сравнивает boolean значения,
    вычисляет левую сторону операции, если она true тогда вычисляет правую сторону.

6. Какие существуют примитивные типы? Их размер?

    byte - 1 byte
    short - 2 byte
    int - 4 byte
    long - 8 byte
    float - 4 byte
    double - 8 byte
    char - 2 byte
    boolean - 1 byte

7. Правило приведения простых типов в Java (в каких случаях нужно приводить явно, в каких нет, почему?)

    из меньшего размера в большее приведение проходит неявно
    из большего размера в меньший надо приводить явно
    если число больше контейнера, к которому его приводят - результат будет непредсказуемый
    при приведении float и double к целочисленным типам дробная часть отсекается
    boolean не приводится ни к какому из типов
    char приводится к числовым типам, как код символа Unicode

8. Что такое char? Можно ли производить арифметические операции над ними? Почему?

    char тип данных, описывающий символы (цифры, буквы, спецсимволы)
    в виде целочисленного значения согласно таблицы UNICODE (UTF-16).

    char считается псевдочисленным типом, поэтому значения этого типа можно задавать в виде числа,
    и проводить над ними арифметические операции. Каждому символу соответствует определенное число из таблицы
    и при получении такого числа в рамках типа char Java выводит его на экран как символ.

9. Что такое класс обертка (wrapper)?

    Так как Java является OOP, то примитивные типы данных должны иметь объектное представление -
    для этого служат классы обертки.
    Примитивные типы данных занимают меньше места, поэтому если не нужна дополнительная функциональность
    лучше использовать их.
    Классы-обертки дают дополнительную функциональность. Имеют методы.
    Классы обертки можно использовать в Collection
    short => Short
    int => Integer
    long => Long
    float => Float
    double => Double
    char => Character
    boolean => Boolean

10. Что такое autoboxing? Пример.

    Автоматическая упаковка примитивного типа в класс-обертку.
    Integer value = 18;
    Также существует unboxing, когда из класса-обертки извлекается значение примитивного типа.

11. Почему нельзя использовать оператор == для объектов?

    Прменение оператора == сравнивает значение в stack.
    Для примитивных типов это будет сравнение значений - что является правильным.
    Для объектов это будет сравнение ссылок хранящихся в stack на адрес в heap, где хранится сам объект.
    а два объекта могут быть иметь одинаковые внутри, но хранятся в разных ячейках памяти, и, соответственно,
    имеют разные ссылки.

12. Что такое pool integer? Диапазон значений.

    Для более эффективного использования памяти в Java используются пулы.
    Когда мы создаем объект не используя операцию new, при помощи valueOf, объект помещается в пул,
    и если мы в дальнейшем захотим создать такой же объект, не используя new, а используя valueOf,
    то новый объект создаваться не будет, а мы просто получим ссылку на объект из пула.
    Для Integer-pool значения хранятся в диапазоне -128...127.

13. Что такое пул строк?

    Это набор строк, который хранится в памяти heap.
    Если мы создаем String без помощи оператора new, а с помощью "",
    сначала ищется такая строка в пуле строк, если находится то возвращается ссылка на существующую строку,
    если нет, то строка добавляется в пул, а потом возвращается ссылка на нее.
    Если String создается, как новый объект с использованием оператора new -
    то принудительно создается новый объект со своей ссылкой.
    Добавить в пул эту строку можно методом intern(). Возвращает строку со значением текущей строки,
    и ссылкой из пула строк (если она уже была в пуле, то существующей, если не было - добавленной).

14. Метод для помещения строки в пул строк.

    Если String создается, как новый объект с использованием оператора new -
    то принудительно создается новый объект со своей ссылкой.
    Добавить в пул эту строку можно методом intern(). Возвращает строку со значением текущей строки,
    и ссылкой из пула строк (если она уже была в пуле, то существующей, если не было - добавленной).

15. Как устроен String в Java? За счет чего реализована неизменность?

    До Java 9 - String для хранения использовал массив char[], c Java 9 используется массив byte[].
    Для вывода символов используется таблица ASCII.
    Так как массив хранящий символы помечен как final -
    и не может переопределяться - достигается неизменяемость (immutable).

16. Что делает метод replaceAll?

    Принимает 2 параметра
    - регулярное выражение regex для поиска соответствия в строке,
    - строка на которую будет проводиться замена.
    Создает новый объект String, в котором заменены все вхождения соответствующие regex на указанную строку.

17. Разница между String и StringBuilder.

    String
    - неизменяемый immutable объект,
    - потокобезопасный за счет неизменяемости,
    - переопределен метод equals(),
    - может создаваться без вызова оператора new

    StringBuilder
    - изменяемый mutable объект,
    - может менять длину и значение через вызов определенных методов.
    - непотокобезопасный (для потокобезопасности используется StringBuffer)
    - не переопределен equals(),
    - быстрее и использует меньше памяти

18. Как работает StringBuilder?

    Наследует AbstractStringBuilder.
    Создается
    - пустым с размером по умолчанию
    - пустым с заданным размером
    - передачей строки в конструктор
    - передачей последовательности символов

    Имеет перегруженный метод append(), может принимать в качестве параметра:
    - String, StringBuffer, CharSequence, CharSequence с указанием начальной и конечной позиции
    - массив char[], массив char[] с указанием начальной и конечной позиции
    - boolean, char, int, long, float, double

    Имеет методы:
    - удаления с параметрами начальной и конечной позиции.
    - удаления символа с параметром номера индекса
    - замены с параметрами начальной и конечной позиции и сроки,
        которая заменит предыдущее содержимое
    - перегруженный метод insert()

    и т.д.

19. Mutable и immutable типы данных?

    Mutable - изменяемый тип, мы можем менять его состояние и поля после того,
    как объект был создан.

    Immutable - неизменяемый тип, мы не можем изменить этот объект после его создания.

20. Как создать свой immutable тип?

    1. Объявить класс final, чтобы запретить наследование.
    2. Сделать все поля private.
    3. Не создавать методы setter для полей.
    4. Сделать mutable поля final.
    5. Инициализировать все поля в конструкторе используя deep copy.
    6. В методах getter выполнить клонирование, чтобы возвращать копии,
        а не реальную ссылку на объект.

21. Что такое рекурсия? Преимущества и недостатки.

    Это техника создания функции/метода для вызова самого себя.
    Преимущества:
    - позволяет разбить сложную задачу на простые, которые легче решить.
    - нужно только определить два случая базовое/конечное условие и рекурсивное условие.
    - некоторые задачи по сути рекурсивны, например дерево.

    Недостатки:
    - требует больше места для хранения информации в стеке,
    так как каждый вызов функции будет оставаться в памяти,
    пока не будет достигнуто базовое/конечное условие.
    - требует больше времени на выполнение, потому что каждый раз,
    когда функция вызывается, стек увеличивается, и ответ возвращается
    когда стек полностью возвращается.

Advanced
1. Максимальное количество объектов в массиве.
    Теоретически 2147483647 / Integer.MAX_VALUE
    На практике это число может быть меньше
    и ограничено количеством памяти выделенным для выполнения программы

2. Почему лучше использовать char[], чем String, для хранения паролей?

    1. Так как String является неизменяемым типом данных, то он будет доступен в памяти
        пока Carbage Collector не очистит его, а так как String используется в пуле
        строк, то есть вероятность длительного хранения такой строки в памяти,
        и тот кто имеет доступ к памяти, может найти там пароль.
        А так как String неизменяем - мы не можем его заменить на что-либо другое.
        В то же время елементы в char[] мы можем установить как пустые или нулевые.
    2. Сама Java рекомендует использовать методы возвращающие пароль в виде char[].
    3. Также есть небольшая вероятность случайного вывода String в логи или консоль.
        В то время как при случайном віводе char[] - мы получим все лишь адрес в памяти.







