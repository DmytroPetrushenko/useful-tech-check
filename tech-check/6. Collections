Basic

1. Что такое generics? Для чего они нужны? Какую проблему решают?

    Обобщения или generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов.
    Когда мы пишем класс или метод то не задаем жестко какой именно параметр будет обработан - а задаем какой то
    неопределенный обобщенный универсальный тип параметра. А уже при создании экземпляра класса мы или другой
    разработчик указывает, какой именно клас будет обрабатываться. И таким образом ограничивает этот экземпляр класса
    на работу только с указанным типом. При попытке работать в этом экземпляре класса с другим типом - будет
    ошибка компиляции.

2. Что такое wildcard?

    <?> - возможность расширения списка подаваемых в объект класса типов.
    <?> ==> <? extends Object>
    <? extends Т> - значит, что в объекте можно работать с классом T и его наследниками.
    <? super T> - значит, что в объекте можно работать с классом T и всей иерархией его предков.


3. PECS.

    Producer extends Consumer super

    <? extends T> может продюсировать передавать генерировать данные для передачи.
    <? super T> может принимать данные для сохранения.

4. Иерархия коллекций.

    (i) Iterable => (i) Collection =>
                    (i) List =>
                        LinkedList
                        ArrayList
                        Vector (s) => Stack
                    (i) Set =>
                        HashSet
                        LinkedHashSet
                        (i) SortedSet => TreeSet
                    (i) Queue =>
                            PriorityQueue (s)
                        (i) Deque =>
                                ArrayDeque
                                LinkedList

5. Внутренняя структура ArrayList.

    Имплементирует интерфейс List. Хранит последовательность добавления.
    Динамический по размеру массив.


6. Начальный размер ArrayList.

    DEFAULT_CAPACITY = 10. Можно задать начальный размер в конструкторе.


7. Какой тип данный возвращает метод add() в List?

    boolean.


8. Во сколько раз увеличивается размер ArrayList после достижения максимального размера?

    oldCapacity * 1,5 + 1.

9. Внутренняя структура LinkedList.

    Имплементирует интерфейс List и Deque. Хранит последовательность добавления.
    Двусвязный список на основе Node. Каждая Node содержит value, ссылку на предыдущую Node, ссылка на следующую Node.
    Первая Node в ссылке на предыдущую Node имеет null.
    Последняя Node в ссылке на следующую Node имеет null.


10. Разница между LinkedList и ArrayList.

    ArrayList - динамический по размеру массив.
    LinkedList - двусвязанный список.
    ArrayList - реализует интерфейс List.
    LinkedList - реализует интерфейс List и Deque.
    ArrayList - быстрее работает для получения элементов из списка, так как просто обращается по индексу.
        Медленнее работает при добавлении, когда необходимо увеличение размера массива, так как создается новый массив,
        происходит копирование старого массива в новый и только потом добавление элемента.
    LinkedList - быстрее работает при добавлении элементов, так как просто переписываются ссылки в
        существующих элементах и добавляются в новом. Медленнее работает при извлечении элементов, так как необходим
        перебор значений и перемещение по ссылкам.

11. Отличие List от Set.

    List сохраняет порядок добавления элементов.
    Set не хранит порядок добавления элементов.
    List позволяет хранить дубликаты и любое количество элементов null.
    Set хранит уникальные элементы, в том числе только одно значение null (можно ли хранить null зависит от реализации).
    List позволяет получать элементы по индексу или перебором, или проверить содержится ли элемент в списке.
    Set позволяет получить элементы перебором или проверить содержится ли элемент в множестве.

12. Внутренняя структура HashSet.

    - хранит уникальные элементы, хранятся в HashMap в виде ключей к этой Map,
        на место значений в этой Map подставляется константа PRESENT = new Object().
    - не хранит порядок добавления элементов,
    - для элементов обязательно переопределение методов equals() и hashCode().

13. Внутренняя структура TreeSet.

    - хранит уникальные элементы, хранятся они в TreeMap в качестве ключей Map,
        на место значений в этой Map подставляется константа PRESENT = new Object().
    - не хранит порядок добавления элементов,
    - сортирует элементы в порядке возрастания (либо тип элемента должен реализовывать Comparable с переопределенным
        методом compareTo(), либо необходимо передать в конструктор Comparator).

14. По какому принципу работают Stack, Queue?

    FIFO (First in - first out)

15. Реализация Map (полностью рассказать про внутреннее устройство, бакеты в HashMap и т.д.


    В основе лежит массив Node<K, V>[] table. Размер массива по умолчанию 16 элементов, ячейка массива в HashMap
    называется бакет.Node параметризована парой ключ-значение.
    Node имеет несколько полей
    - int hash хеш код этого узла-ноды, используется для того, чтобы определить позицию узла-ноды в массиве,
    - K key - ключ, на основании которого и рассчитывается хеш код узла-ноды,
        для него должны быть переопределены методы hashCode() и equals(),
        если ключ null - хеш принимается как равный 0 и значения попадают в 0 ячейку массива,
        если ключ не null - хеш рассчитывается, как остаток от деления хеш кода ключа на текущий размер массива capacity,
        и узел помещается в соответсвующую ячейку массива.
    - V value - хранимое значение,
    - Node<K, V> next - ссылка на следующий узел-ноду.
    Коллизия - ситуация когда после обработки ключа двух объектов получается одинаковый хеш, но ключи разные по equals().
    Они должны попадать в один и тот же бакет. Для этого в узле-ноде есть ссылка на следующий узел-ноду. Это как раз
    и нужно для хранения элементов с одинаковыми значениями хеш. В каждом бакете будет формироваться однонаправленный
    список узлов-нод, то есть в существующем узле-ноде будет записана ссылка на добавляемый узел-ноду. Таким образом
    в одном бакете может храниться несколько узлов-нод со ссылками на следующий узел ноду. При добавлении вычисляется
    хеш, делается попытка добавления в бакет, если там есть значение - то сравниваются ключи по equals(), если они не
    равны, то при наличии ссылки (если она не null) на следующий узел ноды, проводится такая же проверка, и т.д. пока
    не окажется null по ссылке на следующий узел-ноду, в таком случае записывается ссылка на добавляемый объект, и
    получается что добавляемый объект прикрепляется в конец существующего списка. Если при равном хеш, при переборе
    узлов-нод получается, что ключи равны по equals() - то значение в этом узле-ноде перезаписывается на значение из
    добавляемого узла-ноды.
    Изменение размера необходимо для улучшения перформанса и может происходить при вызове метода put. В HashMap есть
    capacity - это размер массива, по умолчанию начальный размер 16.
    loadFactor - это степень/процент загрузки HashMap, по умолчанию 0,75f.
    threshold - значение при достижении которого будет производиться изменение размера массива.
        Вычисляется как capacity * loadFactor.
        Если текущее количество элементов в map (size) становится больше threshold, тогда происходит увеличение
        размера массива в 2 раза, а также перераспределение элементов в map. С перерасчетом значения хеш для каждого
        элемента, так как хеш расчитывается с учетом текущего размера массива capacity.

16. Начальный размер HashMap.

    По умолчанию capacity = 16. Можно задавать в конструкторе. Как и loadFactor, по умолчанию 0,75f.

17. Во сколько раз увеличивается размер HashMap?

    В 2 раза. oldCap << 1.

18. Что такое loadFactor? Значение по дефолту.

    loadFactor - это степень/процент загрузки HashMap, по умолчанию 0,75f.

19. Формула расчета позиции в HashMap.

    hash = hashCode % capacity.

20. Почему объект типа String считается лучшим вариантом для ключа Map?

    String это immutable неизменяемый объект и его хеш-код кешируется во время создания, соответственно его
    не надо вычислять каждый раз, что увеличивает скорость работы. При этом для исключения потери данных
    в Map в качестве ключа рекомендуется использовать immutable объекты, каким и является String.

21. Что лежит внутри реализации HashSet?

    Элементы хранятся в HashMap в виде ключей к этой Map.
    На место значений в этой Map подставляется константа PRESENT = new Object().

22. Итератор, как работает? Для чего нужен? Какие у него методы?

    ??????????????????????????????????????????????????

23. Как сохраняется информация в HashSet, LinkedHashSet, TreeSet?

    ?????????????????????????????????????????????????

Advanced

Опиши будову HashMap з відкритою адресацією. Відповідь
Як дістати елемент з сету? Відповідь
Що таке червоно-чорне дерево? Принцип його роботи. Чим відрізняється від звичайного бінарного? Відповідь